<p>表:&nbsp;<code>Scores</code></p>

<pre>
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| score       | decimal |
+-------------+---------+
id 是该表的主键（有不同值的列）。
该表的每一行都包含了一场比赛的分数。Score 是一个有两位小数点的浮点值。
</pre>

<p>&nbsp;</p>

<p>编写一个解决方案来查询分数的排名。排名按以下规则计算:</p>

<ul> 
 <li>分数应按从高到低排列。</li> 
 <li>如果两个分数相等，那么两个分数的排名应该相同。</li> 
 <li>在排名相同的分数后，排名数应该是下一个连续的整数。换句话说，排名之间不应该有空缺的数字。</li> 
</ul>

<p>按&nbsp;<code>score</code>&nbsp;降序返回结果表。</p>

<p>查询结果格式如下所示。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1:</strong></p>

<pre>
<strong>输入:</strong> 
Scores 表:
+----+-------+
| id | score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
<strong>输出:</strong> 
+-------+------+
| score | rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+</pre>

<div><li>👍 1205</li><li>👎 0</li></div>

要实现这个查询，首先我们需要根据 `score` 字段从高到低排序，并为每个分数分配排名。为了满足题目要求，我们需要处理相同分数的排名问题：如果两个分数相同，那么它们的排名应该相同，并且下一个不同分数的排名应该是连续的。

这个问题可以通过窗口函数（如 `DENSE_RANK()`）来解决。`DENSE_RANK()` 会为每个不同的分数分配排名，如果分数相同，它们会得到相同的排名，并且接下来的排名会连续增加。

下面是对应的 SQL 查询：

```sql
SELECT
    score,
    DENSE_RANK() OVER (ORDER BY score DESC) AS `rank`
FROM Scores
ORDER BY `rank`;
```

### 解释：
1. **`DENSE_RANK() OVER (ORDER BY score DESC)`**:
    - `DENSE_RANK()` 是一个窗口函数，用来为每个分数按降序分配排名。
    - `ORDER BY score DESC` 指定按分数从高到低排序，确保分数高的排在前面。
    - `DENSE_RANK()` 会给相同分数的记录分配相同的排名，且不会跳过排名（即排名是连续的）。

2. **`ORDER BY rank`**:
    - 在最终结果中，我们按 `rank` 排序，确保查询返回的排名是按顺序排列的。

### 示例结果：
根据提供的输入数据，执行这个查询将返回以下结果：

| score | rank |
|-------|------|
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |

这个查询满足了题目中的所有要求：按照分数从高到低排序，相同分数的排名相同，并且排名是连续的。

### 相关说明：
- **`DENSE_RANK()`** 是 SQL 标准窗口函数，它会在处理排名时不跳过排名的数字。与之类似的窗口函数还有 `RANK()`，但 `RANK()` 会跳过排名（即如果两个分数排名相同，则下一个分数的排名会跳过）。
