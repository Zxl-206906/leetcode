<p>表：<code>Logs</code></p>

<pre>
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| num         | varchar |
+-------------+---------+
在 SQL 中，id 是该表的主键。
id 是一个自增列。</pre>

<p>&nbsp;</p>

<p>找出所有至少连续出现三次的数字。</p>

<p>返回的结果表中的数据可以按 <strong>任意顺序</strong> 排列。</p>

<p>结果格式如下面的例子所示：</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入：</strong>
Logs 表：
+----+-----+
| id | num |
+----+-----+
| 1  | 1   |
| 2  | 1   |
| 3  | 1   |
| 4  | 2   |
| 5  | 1   |
| 6  | 2   |
| 7  | 2   |
+----+-----+
<strong>输出：</strong>
Result 表：
+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+
<strong>解释：</strong>1 是唯一连续出现至少三次的数字。</pre>

<div><li>👍 890</li><li>👎 0</li></div>


要找出所有在表中至少连续出现三次的数字，我们可以通过以下步骤来解决问题：

### 思路：
1. **连续数字**：我们需要找到连续重复出现的数字。由于表中的 `id` 是自增的，我们可以利用 `id` 顺序来查找相邻的行。
2. **分组**：我们需要按数字 `num` 来分组，判断是否有连续相同的数字。
3. **窗口函数**：可以使用窗口函数（`LEAD` 或 `LAG`）来比较当前行和前一行、后一行的数字，找出连续相同的数字。
4. **计数**：对于每个连续的数字序列，检查是否至少有三次连续出现。

### SQL 查询：
我们可以使用 **窗口函数** 来解决这个问题，利用 `LEAD` 和 `LAG` 函数来判断相邻行的数字是否相同。

```sql
WITH Consecutive AS (
    SELECT 
        num,
        ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) AS rn
    FROM Logs
)
SELECT DISTINCT num AS ConsecutiveNums
FROM Consecutive
WHERE rn - ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) >= 2;
```

### 解释：
1. **`ROW_NUMBER() OVER (PARTITION BY num ORDER BY id)`**：这是一个窗口函数，它对每个数字 `num` 分配一个唯一的顺序号，`id` 自增确保行的顺序。
2. **`WHERE` 子句**：通过比较当前行的 `rn` 和相同数字分组中的行号差，来找出连续出现的数字。如果差值大于或等于 2，则说明当前数字连续出现至少三次。
3. **`DISTINCT`**：为了确保返回的结果没有重复的数字，使用 `DISTINCT` 去除重复的 `num` 值。

### 示例分析：
对于给定的输入：
```
+----+-----+
| id | num |
+----+-----+
| 1  | 1   |
| 2  | 1   |
| 3  | 1   |
| 4  | 2   |
| 5  | 1   |
| 6  | 2   |
| 7  | 2   |
+----+-----+
```

- `1` 在 `id = 1, 2, 3` 行连续出现 3 次。
- 结果应该返回 `1` 作为至少连续出现三次的数字。

**输出结果：**
```
+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+
```

该查询能够正确地找出所有至少连续出现三次的数字，并返回相应的结果。