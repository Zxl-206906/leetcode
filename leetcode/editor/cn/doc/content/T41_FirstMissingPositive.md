<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p> 请你实现时间复杂度为 
<code>O(n)</code> 并且只使用常数级别额外空间的解决方案。

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,2,0]
<strong>输出：</strong>3
<strong>解释：</strong>范围 [1,2] 中的数字都在数组中。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [3,4,-1,1]
<strong>输出：</strong>2
<strong>解释：</strong>1 在数组中，但 2 没有。</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [7,8,9,11,12]
<strong>输出：</strong>1
<strong>解释：</strong>最小的正数 1 没有出现。</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li> 
 <li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li> 
</ul>

<div><li>👍 2236</li><li>👎 0</li></div>


### **问题解析**

#### 要求：
1. 找出未出现的最小正整数。
2. 时间复杂度要求为 **O(n)**，空间复杂度要求为 **O(1)**。

#### 核心思路：
- 利用数组本身作为哈希表的思想，将数字放到它应该在的位置（**索引 = 值 - 1**）。
- 通过对数组就地操作，最终快速定位缺失的最小正整数。

---

### **解决步骤**

#### **步骤 1：将元素放置到正确的位置**
- 遍历数组：
    - 如果 `nums[i]` 是正数，且在 `[1, n]` 范围内（`n` 为数组长度），并且当前 `nums[i]` 还未放到正确位置（即 `nums[nums[i] - 1] != nums[i]`），则将其交换到正确位置。
- 这样一轮遍历后，所有在 `[1, n]` 范围内的正整数都放到了正确索引上。

#### **步骤 2：找出未出现在正确位置的数字**
- 再次遍历数组：
    - 第一个位置 `i` 满足 `nums[i] != i + 1`，则缺失的最小正整数为 `i + 1`。
- 如果所有数字都正确，则返回 `n + 1`。

#### **关键点：**
1. **时间复杂度为 O(n)**：
    - 每个数字最多交换一次，总共最多遍历两次。
2. **空间复杂度为 O(1)**：
    - 所有操作在原数组上完成，没有额外的空间开销。

---

### **Java代码实现**

```java
public class FirstMissingPositive {
    public static int firstMissingPositive(int[] nums) {
        int n = nums.length;

        // 第一步：将数字放置到正确的位置
        for (int i = 0; i < n; i++) {
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                swap(nums, i, nums[i] - 1);
            }
        }

        // 第二步：查找第一个不在正确位置的数字
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                return i + 1; // 返回缺失的正整数
            }
        }

        // 如果所有数字都在正确位置，返回 n + 1
        return n + 1;
    }

    // 交换两个索引的元素
    private static void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    public static void main(String[] args) {
        // 示例测试
        System.out.println(firstMissingPositive(new int[]{1, 2, 0})); // 输出：3
        System.out.println(firstMissingPositive(new int[]{3, 4, -1, 1})); // 输出：2
        System.out.println(firstMissingPositive(new int[]{7, 8, 9, 11, 12})); // 输出：1
    }
}
```

---

### **代码执行流程**

#### 示例 1：
输入：`nums = [1, 2, 0]`

1. **初始数组**：`[1, 2, 0]`
2. **调整位置**：
    - 第一个数字 `1` 已在正确位置。
    - 第二个数字 `2` 已在正确位置。
    - 第三个数字 `0` 不处理（不是正整数）。
3. **调整后数组**：`[1, 2, 0]`
4. **查找缺失数字**：
    - 索引 `0` 满足 `nums[0] == 1`。
    - 索引 `1` 满足 `nums[1] == 2`。
    - 索引 `2` 不满足 `nums[2] == 3`，返回 `3`。

输出：`3`

---

#### 示例 2：
输入：`nums = [3, 4, -1, 1]`

1. **初始数组**：`[3, 4, -1, 1]`
2. **调整位置**：
    - 第一个数字 `3` 交换到位置 `2`：`[-1, 4, 3, 1]`
    - 数字 `1` 交换到位置 `0`：`[1, 4, 3, -1]`
    - 数字 `4` 交换到位置 `3`：`[1, -1, 3, 4]`
3. **调整后数组**：`[1, -1, 3, 4]`
4. **查找缺失数字**：
    - 索引 `0` 满足 `nums[0] == 1`。
    - 索引 `1` 不满足 `nums[1] == 2`，返回 `2`。

输出：`2`

---

#### 示例 3：
输入：`nums = [7, 8, 9, 11, 12]`

1. **初始数组**：`[7, 8, 9, 11, 12]`
2. **调整位置**：无有效交换（所有数字均大于数组长度）。
3. **调整后数组**：`[7, 8, 9, 11, 12]`
4. **查找缺失数字**：
    - 索引 `0` 不满足 `nums[0] == 1`，返回 `1`。

输出：`1`

---

### **时间复杂度分析**
1. **数组调整**：
    - 每个数字最多只会被交换一次，时间复杂度为 \(O(n)\)。
2. **查找缺失数字**：
    - 遍历一次数组，时间复杂度为 \(O(n)\)。

总时间复杂度：**\(O(n)\)**。

---

### **空间复杂度分析**
- 使用原数组存储数据，无额外的空间开销，空间复杂度为 **\(O(1)\)**。

---

### **总结**
- 本题利用**原地哈希**的方法，将问题压缩到线性时间复杂度。
- 关键在于通过交换操作让每个正整数都尽可能回到对应位置，再通过一次遍历找到结果。